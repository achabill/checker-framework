This is a list of the intro and transfer rules for the Lower Bound Checker:

The type hierarchy is:

   Top = lbu ("Lower Bound Unknown")
    |
   gte-1 ("Greater than or equal to -1")
    |
   nn  ("NonNegative")
    |
   pos ("Positive")

Intro rules (implemented in LowerBoundAnnotatedTypeFactory):

First, check if the Constant Value Checker has an estimate for the value
of the expression.  If so, use the most precise type that includes all the
values, which is the most precise type that includes the minimum value.

Otherwise, use the following rules for unary and binary expressions:

Increment:
               pos -> pos
               nn -> pos
               gte-1 -> nn
               lbu -> lbu

Decrement:
               pos -> nn
               nn -> gte-1
               gte-1, lbu -> lbu

Plus (rules are symmetric):
               lit -2 + pos -> gte-1
               lit -1 + * -> call decrement
               lit 0 + * -> *
	       lit 1 + * -> call increment
	       lit >= 2 + {gte-1, nn, or pos} -> pos
	       let all other lits, including sets, fall through:
	       pos + pos -> pos
	       nn + * -> *
	       pos + gte-1 -> nn
	       nn + gte-1 -> gte-1
	       * + * -> lbu

Minus:
               * - lit -> call plus(*, -1 * the value of the lit)
	       * - * -> lbu

Multiply (rules are symmetric):
	       * * lit 0 -> nn (=0)
	       * * lit 1 -> *
	       pos * pos -> pos
	       pos * nn -> nn
	       nn * nn -> nn
	       * * * -> lbu

Integer Division:
	       lit 0 / * -> nn (=0)
	       * / lit 1 -> *
	       pos / {pos, nn} -> nn (can round to zero)
	       * / {pos, nn} -> *
	       * / * -> lbu

Mod:
	       * % 1/-1 -> nn (=0)
	       pos/nn % * -> nn
	       gte-1 % * -> gte-1
	       lbu % * -> lbu


Refinement/transfer rules for conditionals (LowerBoundTransfer.java):

There are two "primitives":

x > y, which implies things about x based on y's type:

y has type:    implies x has type:
  gte-1                nn
  nn                   pos
  pos                  pos

and x >= y:

y has type:    implies x has type:
  gte-1                gte-1
  nn                   nn
  pos                  pos

Then, we can use these two "building blocks" to make all
other conditional expressions:

EXPR             THEN          ELSE
x > y            x > y         y >= x
x >= y           x >= y        y > x
x < y            y > x         x >= y
x <= y           y >= x        x > y

Or, more formally:

EXPR        THEN                                        ELSE
x > y       x_refined = GLB(x_orig, promote(y))         y_refined = GLB(y_orig, x)
x >= y      x_refined = GLB(x_orig, y)                  y_refined = GLB(y_orig, promote(x))
x < y       y_refined = GLB(y_orig, promote(x))         x_refined = GLB(x_orig, y)
x <= y      y_refined = GLB(y_orig, x)                  x_refined = GLB(x_orig, promote(y))

where GLB is the greatest lower bound and promote is the increment
function on types (or, equivalently, the function specified by the "x
> y" information above).

There's also ==, which is a special case. We only know
things about the THEN branch:

EXPR             THEN                   ELSE
x == y           x >= y && y >= x       nothing known

or, more formally:

EXPR            THEN                                    ELSE
x == y          x_refined = GLB(x_orig, y_orig)         nothing known
                y_refined = GLB(x_orig, y_orig)

finally, not equal:

EXPR             THEN                   ELSE
x != y           nothing known          x >= y && y >= x

more formally:

EXPR            THEN               ELSE
x != y          nothing known      x_refined = GLB(x_orig, y_orig)
                                   y_refined = GLB(x_orig, y_orig)
