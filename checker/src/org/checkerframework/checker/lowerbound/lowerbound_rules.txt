This is mostly just a list of the intro and transfer rules for the LBC:

The type hierarchy is:

   Top = lbu (unknown)
    |
   n1p ("Negative One Plus")
    |
   nn  ("NonNegative")
    |
   pos ("Positive")

Intro rules (LowerBoundAnnotatedTypeFactory):

Int lit -> use its literal value

Increment:     pos -> pos
               nn -> pos
               n1p -> nn
               * -> lbu

Decrement:     pos -> nn
               Nn -> n1p
               * -> lbu

Plus:	       int lit + int lit -> do the math
	       lit 0 + * -> *
	       lit 1 + * -> call increment
	       lit -1 + * -> call decrement
	       lit >= 2 + n1p, nn, or pos -> pos
	       lit -2 + pos -> n1p
	       let all other lits fall through:
	       pos + pos -> pos
	       pos + nn -> pos
	       nn + nn -> nn
	       pos + n1p -> nn
	       nn + n1p -> n1p
	       * + * -> lbu

Minus:
	       int lit - int lit -> do the math
	       * - lit 0 -> *
	       * - lit 1 -> call decrement
	       * - lit -1 -> call increment
	       pos - lit 2 -> n1p
	       n1p, nn, pos - lit <= -2 -> pos
	       * - * -> lbu

Multiply:

	       int lit * int lit -> do the math
	       * * lit 0 -> nn (=0)
	       * * lit 1 -> *
	       pos * pos -> pos
	       pos * nn -> nn
	       nn * nn -> nn
	       * * * -> lbu

Divide:
	       int lit / int lit -> do the math
	       lit 0 / * -> nn (=0)
	       * / lit 1 -> *
	       pos / pos -> nn
	       nn / pos -> nn
	       pos / nn -> nn
	       nn / nn -> nn
	       n1p / pos -> n1p
	       n1p / nn -> n1p
	       * / * -> lbu

Mod:

	       int lit % int lit -> do the math
	       * % 1/-1 -> nn (=0)
	       pos/nn % * -> nn
	       n1p % * -> n1p
	       lbu % * -> lbu


Refinement/transfer rules for conditionals (LowerBoundTransfer.java):

There are two "primitives":

x > y, which implies things about x based on y's type:

y has type:    implies x has type:
  n1p                  nn
  nn                   pos
  pos                  pos

and x >= y:

y has type:    implies x has type:
  n1p                  n1p
  nn                   nn
  pos                  pos

Then, we can use these two "building blocks" to make all
other conditional expressions:

EXPR             THEN          ELSE
x > y            x > y         y >= x
x >= y           x >= y        y > x
x < y            y > x         x >= y
x <= y           y >= x        x > y

There's also ==, which is a special case. We only know
things about the THEN branch:

EXPR             THEN
x == y           x >= y && y >= x
