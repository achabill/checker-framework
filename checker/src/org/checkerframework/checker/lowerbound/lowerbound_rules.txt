This is a list of the intro and transfer rules for the Lower Bound Checker:

The type hierarchy is:

   Top = lbu ("Lower Bound Unknown")
    |
   gte-1 ("Greater than or equal to -1")
    |
   nn  ("NonNegative")
    |
   pos ("Positive")

Intro rules (implemented in LowerBoundAnnotatedTypeFactory):

First, check if the value checker can determine the value of any expression
at compile time. If so:

   Single int literal -> use the lowest type that includes the value
   Set of int literals -> find the min value, then apply the above rule

Otherwise, use the following rules for unary and binary expressions:

Increment:     
               pos -> pos
               nn -> pos
               gte-1 -> nn
               * -> lbu

Decrement:     
               pos -> nn
               Nn -> gte-1
               * -> lbu

Plus (rules are symmetric):          	       
               lit -2 + pos -> gte-1
               lit -1 + * -> call decrement
               lit 0 + * -> *
	       lit 1 + * -> call increment
	       lit >= 2 + gte-1, nn, or pos -> pos
	       let all other lits, including sets, fall through:
	       pos + pos -> pos
	       pos + nn -> pos
	       nn + nn -> nn
	       pos + gte-1 -> nn
	       nn + gte-1 -> gte-1
	       * + * -> lbu

Minus:
               * - lit -> call plus(*, -1 * the value of the lit)
	       * - * -> lbu

Multiply (rules are symmetric):
	       * * lit 0 -> nn (=0)
	       * * lit 1 -> *
	       pos * pos -> pos
	       pos * nn -> nn
	       nn * nn -> nn
	       * * * -> lbu

Divide:
	       lit 0 / * -> nn (=0)
	       * / lit 1 -> *
	       pos / pos -> nn
	       nn / pos -> nn
	       pos / nn -> nn
	       nn / nn -> nn
	       gte-1 / pos -> gte-1
	       gte-1 / nn -> gte-1
	       * / * -> lbu

Mod:
	       * % 1/-1 -> nn (=0)
	       pos/nn % * -> nn
	       gte-1 % * -> gte-1
	       lbu % * -> lbu


Refinement/transfer rules for conditionals (LowerBoundTransfer.java):

There are two "primitives":

x > y, which implies things about x based on y's type:

y has type:    implies x has type:
  gte-1                nn
  nn                   pos
  pos                  pos

and x >= y:

y has type:    implies x has type:
  gte-1                gte-1
  nn                   nn
  pos                  pos

Then, we can use these two "building blocks" to make all
other conditional expressions:

EXPR             THEN          ELSE
x > y            x > y         y >= x
x >= y           x >= y        y > x
x < y            y > x         x >= y
x <= y           y >= x        x > y

Or, more formally:

EXPR        THEN                                        ELSE
x > y       x_refined = GLB(x_orig, promote(y))         y_refined = GLB(y_orig, x)
x >= y      x_refined = GLB(x_orig, y)                  y_refined = GLB(y_orig, promote(x))
x < y       y_refined = GLB(y_orig, promote(x))         x_refined = GLB(x_orig, y)
x <= y      y_refined = GLB(y_orig, x)                  x_refined = GLB(x_orig, promote(y))

where GLB is the greatest lower bound and promote is the function that moves a type to the
type one below it in the hierarchy (or, equivalently, the function specified by the "x > y"
information above).

There's also ==, which is a special case. We only know
things about the THEN branch:

EXPR             THEN                   ELSE
x == y           x >= y && y >= x       nothing known

finally, not equal:

EXPR             THEN                   ELSE
x != y           nothing known          x >= y && y >= x
